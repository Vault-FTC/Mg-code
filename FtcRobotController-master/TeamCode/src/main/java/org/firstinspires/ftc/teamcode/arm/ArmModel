package org.firstinspires.ftc.teamcode.arm;

public class ArmModel {

    // IS THE ARM PLACING OR PICKING UP
    boolean placing_mode = true;
    boolean picking_up_mode = false;
    boolean idle_mode = false;

    // Arm One's CURRENT known values
    final double arm_one_len = 12; // Inches
    double arm_one_ang_in_degrees = 30; // Degrees

    // Arm Two's CURRENT known values
    final double arm_two_len = 4; // Inches
    double arm_two_ang_in_degrees = 30; // Degrees

    // The dimensions of our CURRENT ROBOT
    final double x_space_available = 18; // Inches
    double y_space_available = 12; // Inches
    final double robot_base_height = 3; // Inches; Distance from the ground to the start of the Linear Slide
    final double board_angle_in_radians = Math.toRadians(60);
    final double board_complementary_in_radians = Math.toRadians(90) - board_angle_in_radians;
    final double board_supplementary_in_radians = Math.toRadians(180) - board_angle_in_radians;

    // Robot Intake details
    double intake_cutoff_dist = 8; // Inches
    double intake_angle = 10; // Degrees; The slope of the intake before cutoff
    double intake_spinner_height = 3; // Inches
    double intake_spinner_radius = 5; // Inches

    // Linear Slide CURRENT known values
    double min_len_of_slide = 10.4; // Inches; Size of the Linear Slide fully compressed
    double max_len_of_slide = 23; // Inches; Size of the Linear Slide fully enlarged
    double slide_dist_from_intake = 11; // Inches; The distance from the intake edge of the robot to the base of the Linear Slide
    double x_distance_from_pivot_to_front = slide_dist_from_intake + min_len_of_slide * Math.cos(board_angle_in_radians)-18; // Inches
    final double height_base_to_slide_top = min_len_of_slide * Math.sin(board_angle_in_radians); // inches

    public ArmGoals calculateArmPos(double distanceToTarget) {
        ArmGoals goals = new ArmGoals();
        goals.targetAngleElbow = find_arm_one_ang_goal(distanceToTarget);
        goals.targetAngleWrist = find_arm_two_ang_goal(distanceToTarget);
        goals.LinearSlideExtension = find_linear_slide_extension();
        return goals;
    }

    public double find_arm_one_ang_goal(double distance_to_target) {
        double pivot_point_height = robot_base_height + height_base_to_slide_top;
        // Find the x distance from the pivot point on the robot's elbow after arm2's x-length is coaxed out.
        double pivot_point_to_board_placement = distance_to_target + x_distance_from_pivot_to_front - (arm_two_len * Math.cos(board_angle_in_radians));
        double magical_diagonal_distance = Math.sqrt( (pivot_point_height * pivot_point_height) + (pivot_point_to_board_placement * pivot_point_to_board_placement) );

        if (pivot_point_to_board_placement >= 0) {
            // THE FOLLOWING HAS REFERENCES TO A PICTURE! TALK TO DAVID FOR THESE REFERENCES!

            // Theta one
            double base_ang_for_magic_diagonal = Math.atan((pivot_point_height / pivot_point_to_board_placement));

            // Theta two
            double board_ang_for_magic_diagonal = (board_supplementary_in_radians) - base_ang_for_magic_diagonal;

            // Theta three
            double board_intersection_ang_for_arm = Math.asin( ( ( magical_diagonal_distance * Math.sin(board_ang_for_magic_diagonal) ) / arm_one_len) );

            // Theta four
            double arm_ang_for_magic_diagonal = Math.toRadians(180) - board_ang_for_magic_diagonal - board_intersection_ang_for_arm;

            // Theta five
            double height_ang_for_magic_diagonal = Math.atan(pivot_point_to_board_placement / pivot_point_height);

            // Theta five + Theta four
            double angle_from_bottom_in_radians = arm_ang_for_magic_diagonal + height_ang_for_magic_diagonal;

            // Return the angle of the arm, 0 deg is  parallel to the ground
            return angle_from_bottom_in_radians - Math.toRadians(90);



        } else {
            double theta_one = -board_angle_in_radians + Math.atan( pivot_point_height / -pivot_point_to_board_placement );

            double height_one = ( magical_diagonal_distance * Math.sin( theta_one ) ) / Math.sin( Math.toRadians(180) - board_complementary_in_radians );

            double theta_three = Math.asin( ( height_one * Math.sin(board_complementary_in_radians) ) / (arm_one_len) );

            double theta_four = Math.toRadians(180) - board_complementary_in_radians - theta_three;

            return theta_four - Math.toRadians(90);

        }


    }

    public double find_arm_two_ang_goal(double distance_to_target) {
        // Arm two angle is referred to where 0 degrees is the perpendicular line to Arm one
        return -find_arm_one_ang_goal(distance_to_target) + Math.toRadians(60);
    }

    public double find_linear_slide_extension() {
        // This is given my the user

        return 0;
    }
}
